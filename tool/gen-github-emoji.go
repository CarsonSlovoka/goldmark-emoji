package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

const OutBaseDir = "../v2/def"

const TemplateContent = `// This file was generated by ../../tools/gen-github-emoji.go. DO NOT EDIT.

package def

func Github() Emojis {
	return NewEmojis(
		{{- range $e := .Datas }}
		NewEmoji("{{$e.Desc}}", []rune{ {{- s2runes $e.Value -}} }, {{stringsJoin $e.Aliases ","}}),
		{{- end}}
		{{/* NewEmoji("ðŸ˜Š", []rune{0x1F60A}, "blush", "smiling_face_with_smiling_eyes", "å¾®ç¬‘"), */}}
	)
}
`

func httpGet(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	return io.ReadAll(resp.Body)
}

type DbEmoji struct {
	Datas []struct {
		Value          string `json:"emoji"`
		Desc           string `json:"description"`
		Category       string
		Aliases        []string
		Tags           []string
		UnicodeVersion string `json:"unicode_version"`
		IosVersion     string `json:"ios_version"`
	}
}

/*
 {
    "emoji": "ðŸ˜€",
    "description": "grinning face",
    "category": "Smileys & Emotion",
    "aliases": [
      "grinning"
    ],
    "tags": [
      "smile",
      "happy"
    ],
    "unicode_version": "6.1",
    "ios_version": "6.0"
  }
*/

func main() {
	fmt.Println("generate github")
	outPath := filepath.Join(OutBaseDir, "github-emoji.go")

	bs, err := httpGet("https://raw.githubusercontent.com/github/gemoji/master/db/emoji.json")
	if err != nil {
		log.Fatal(err)
	}

	var db DbEmoji
	if err = json.Unmarshal(bs, &db.Datas); err != nil {
		log.Fatal(err)
	}

	outF, err := os.Create(outPath)
	if err != nil {
		log.Fatal(err)
	}
	defer outF.Close()

	t := template.Must(template.New("").Funcs(map[string]any{
		"s2runes": func(s string) string {
			var unicodes []string
			for _, c := range s {
				unicodes = append(unicodes, fmt.Sprintf("0x%s", strconv.FormatUint(uint64(c), 16)))
			}
			return strings.Join(unicodes, ",")
		},
		"stringsJoin": func(elems []string, sep string) string {
			var result string
			for _, e := range elems {
				result += fmt.Sprintf(`"%s"%s`, e, sep)
			}
			if len(result) > 0 {
				result = result[0 : len(result)-1] // remove the last "sep"
			}
			return result
		},
	}).Parse(TemplateContent))
	if err = t.Execute(outF, db); err != nil {
		log.Fatal(err)
	}
}
